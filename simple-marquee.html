<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Now Playing Text Marquee</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f5f5f5;
        }
        
        .demo-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 600px;
        }
        
        /* Main marquee container */
        .marquee-container {
            width: 200px;
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            overflow: hidden;
            position: relative;
        }
        
        /* The text element that will scroll */
        .marquee-text {
            white-space: nowrap;
            display: inline-block;
            position: relative;
        }
        
        /* Controls for demo */
        .test-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        button {
            padding: 8px 12px;
            cursor: pointer;
        }
        
        .container-controls {
            margin-top: 10px;
        }
        
        .status-display {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="demo-section">
        <h2>Now Playing Text Marquee</h2>
        
        <div>
            <div class="marquee-container" id="marquee-container">
                <div class="marquee-text" id="marquee-text">This is a sample text that will scroll if needed</div>
            </div>
            
            <div class="status-display">
                <div>Text width: <span id="text-width-display">0</span>px</div>
                <div>Container width: <span id="container-width-display">0</span>px</div>
                <div>Status: <span id="scroll-status">Checking...</span></div>
                <div>Next scroll in: <span id="next-scroll-time">-</span></div>
            </div>
        </div>
        
        <div class="test-buttons">
            <button id="short-text">Short Text</button>
            <button id="medium-text">Medium Text</button>
            <button id="long-text">Very Long Text</button>
            <button id="restart">Restart Scroll</button>
        </div>
        
        <div class="container-controls">
            <button id="narrow-container">Narrow Container</button>
            <button id="wide-container">Wide Container</button>
        </div>
    </div>

    <script>
        // Get DOM elements
        const container = document.getElementById('marquee-container');
        const textElement = document.getElementById('marquee-text');
        const textWidthDisplay = document.getElementById('text-width-display');
        const containerWidthDisplay = document.getElementById('container-width-display');
        const scrollStatus = document.getElementById('scroll-status');
        const nextScrollTime = document.getElementById('next-scroll-time');
        
        // Variables for controlling scroll behavior
        let isScrolling = false;
        let needsScroll = false;
        let scrollTimer = null;
        let countdownInterval = null;
        const initialDelay = 2000; // 2 seconds after init before first scroll
        const scrollInterval = 15000; // 15 seconds between scrolls
        const scrollDuration = 8000; // How long a single scroll animation takes
        
        // Store original text
        let originalText = '';
        
        // Function to measure text and container widths
        function measureWidths() {
            // Container width is straightforward
            const containerWidth = container.clientWidth;
            
            // For text width, we need to ensure it's not constrained
            const clone = textElement.cloneNode(true);
            clone.style.display = "inline-block";
            clone.style.width = "auto";
            clone.style.position = "absolute";
            clone.style.visibility = "hidden";
            document.body.appendChild(clone);
            const textWidth = clone.offsetWidth;
            document.body.removeChild(clone);
            
            // Update display
            textWidthDisplay.textContent = textWidth;
            containerWidthDisplay.textContent = containerWidth;
            
            return { textWidth, containerWidth };
        }
        
        // Function to check if scrolling is needed
        function checkNeedsScroll() {
            // Store the original text if we haven't already
            if (!originalText) {
                originalText = textElement.textContent;
            } else {
                // Reset to original text for measurement
                textElement.textContent = originalText;
            }
            
            const { textWidth, containerWidth } = measureWidths();
            needsScroll = textWidth > containerWidth;
            
            // Update status display
            if (needsScroll) {
                scrollStatus.textContent = 'Will scroll (text wider than container)';
                scrollStatus.style.color = 'green';
                
                // Add duplicate text
                textElement.textContent = originalText + '   ' + originalText;
            } else {
                scrollStatus.textContent = 'Static (text fits container)';
                scrollStatus.style.color = 'blue';
            }
            
            return needsScroll;
        }
        
        // Function to perform the scroll animation
        function performScroll() {
            if (!needsScroll) return;
            
            // Get current measurements
            const { textWidth, containerWidth } = measureWidths();
            isScrolling = true;
            
            // Calculate halfway point (original text length)
            const scrollDistance = textWidth / 2;
            
            // Set the animation duration
            const duration = scrollDuration / 1000; // Convert to seconds
            
            // Start the animation smoothly
            textElement.style.transition = `transform ${duration}s linear`;
            textElement.style.transform = `translateX(-${scrollDistance}px)`;
            
            // Update status
            scrollStatus.textContent = 'Currently scrolling...';
            
            // Reset after scroll completes
            setTimeout(() => {
                // Reset position without animation
                textElement.style.transition = 'none';
                textElement.style.transform = 'translateX(0)';
                
                // Force reflow to make the transition removal take effect
                void textElement.offsetWidth;
                
                // Restore transition property for next scroll
                textElement.style.transition = `transform ${duration}s linear`;
                
                isScrolling = false;
                scrollStatus.textContent = 'Waiting for next scroll';
                
                // Schedule next scroll
                scheduleNextScroll();
            }, scrollDuration);
        }
        
        // Function to schedule the next scroll
        function scheduleNextScroll() {
            // Clear any existing timer
            if (scrollTimer) clearTimeout(scrollTimer);
            if (countdownInterval) clearInterval(countdownInterval);
            
            if (!needsScroll) {
                nextScrollTime.textContent = 'Not needed';
                return;
            }
            
            // Set next scroll time
            let timeRemaining = scrollInterval / 1000;
            nextScrollTime.textContent = `${timeRemaining}s`;
            
            // Update countdown display
            countdownInterval = setInterval(() => {
                timeRemaining--;
                nextScrollTime.textContent = `${timeRemaining}s`;
                
                if (timeRemaining <= 0) {
                    clearInterval(countdownInterval);
                }
            }, 1000);
            
            // Schedule next scroll
            scrollTimer = setTimeout(performScroll, scrollInterval);
        }
        
        // Initialize the marquee
        function initMarquee() {
            // Store original text
            originalText = textElement.textContent;
            
            // Check if scrolling is needed
            checkNeedsScroll();
            
            // Schedule first scroll after initial delay
            if (needsScroll) {
                nextScrollTime.textContent = `${initialDelay/1000}s`;
                scrollTimer = setTimeout(performScroll, initialDelay);
            }
        }
        
        // Handle resizing and content changes
        function handleChange() {
            // Stop any ongoing animations
            if (scrollTimer) clearTimeout(scrollTimer);
            if (countdownInterval) clearInterval(countdownInterval);
            
            // Update original text if not from a test button
            const currentText = textElement.textContent;
            if (!currentText.includes(originalText) && 
                !originalText.includes(currentText)) {
                originalText = currentText;
            }
            
            // Reset position
            textElement.style.transition = 'none';
            textElement.style.transform = 'translateX(0)';
            
            // Check if scrolling is needed with the new content/size
            checkNeedsScroll();
            
            // Restart the scroll cycle
            if (needsScroll) {
                nextScrollTime.textContent = `${initialDelay/1000}s`;
                scrollTimer = setTimeout(performScroll, initialDelay);
            } else {
                nextScrollTime.textContent = 'Not needed';
            }
        }
        
        // Initialize on page load
        window.addEventListener('load', initMarquee);
        
        // Update on window resize
        window.addEventListener('resize', handleChange);
        
        // Test buttons for different text lengths
        document.getElementById('short-text').addEventListener('click', function() {
            originalText = "Short text";
            textElement.textContent = originalText;
            handleChange();
        });
        
        document.getElementById('medium-text').addEventListener('click', function() {
            originalText = "This is a medium length text that might need to scroll";
            textElement.textContent = originalText;
            handleChange();
        });
        
        document.getElementById('long-text').addEventListener('click', function() {
            originalText = "This is a very long text that will definitely need to scroll because it's much wider than our container width and we want to make sure it works properly";
            textElement.textContent = originalText;
            handleChange();
        });
        
        // Container width controls
        document.getElementById('narrow-container').addEventListener('click', function() {
            container.style.width = '150px';
            handleChange();
        });
        
        document.getElementById('wide-container').addEventListener('click', function() {
            container.style.width = '350px';
            handleChange();
        });
        
        // Restart button
        document.getElementById('restart').addEventListener('click', function() {
            handleChange();
        });
    </script>
</body>
</html>
