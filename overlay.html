<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Now Playing</title>
    <!-- Import multiple fonts for different themes -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700&family=Inter:wght@400;700&family=Poppins:wght@400;700&family=Quicksand:wght@400;700&family=Rubik:wght@400;700&display=swap" rel="stylesheet">
    <!-- Custom fonts -->
    <!-- Retro-Gaming.ttf font from Daymarius (https://www.dafont.com/retro-gaming.font) -->
    <!-- Press Start 2P font by CodeMan38, licensed under SIL Open Font License -->
    <!-- Atkinson Hyperlegible font designed for the Braille Institute for improved readability -->
    <style>
        @font-face {
            font-family: 'Retro Gaming';
            src: url('/assets/fonts/PressStart2P-Regular.ttf') format('truetype'),
                 url('/assets/fonts/Retro-Gaming.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'Atkinson Hyperlegible';
            src: url('/assets/fonts/AtkinsonHyperlegible-Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'Atkinson Hyperlegible';
            src: url('/assets/fonts/AtkinsonHyperlegible-Bold.ttf') format('truetype');
            font-weight: bold;
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrains Mono';
            src: url('/assets/fonts/JetBrainsMono[wght].ttf') format('truetype-variations');
            font-weight: 100 900; /* Variable font weight range */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrains Mono';
            src: url('/assets/fonts/JetBrainsMono-Italic[wght].ttf') format('truetype-variations');
            font-weight: 100 900; /* Variable font weight range */
            font-style: italic;
        }
    </style>
    <style>
        /* Base styles */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: transparent;
            transition: all 0.3s ease;
        }
        
        .overlay-container {
            position: relative;
            width: fit-content;
        }
        
        .music-container {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            max-width: 500px;
            margin: 10px;
            animation: fadeIn 0.5s ease-in-out;
            transition: all 0.5s ease;
            position: relative;
        }
        
        .hidden {
            opacity: 0;
            transform: translateY(-10px);
        }
        
        .album-art {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            margin-right: 15px;
            flex-shrink: 0;
            transition: all 0.3s ease;
            overflow: hidden;
            background-size: cover;
            background-position: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .note-icon {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            margin-right: 15px;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }
        
        .song-info {
            font-size: 18px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .song-title {
            font-weight: 700;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .song-artist {
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Theme selector (hidden by default) */
        .theme-selector {
            position: absolute;
            left: 10px;
            background-color: rgba(30, 30, 30, 0.75);
            border-radius: 8px;
            padding: 8px;
            display: flex;
            gap: 8px;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            align-items: flex-start;
        }
        
        .overlay-container:hover .theme-selector {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Width settings */
        .width-adaptive {
            width: fit-content;
        }
        
        .width-fixed {
            width: 100%;
        }
        
        .width-fixed .music-container {
            max-width: none;
        }
        
        .theme-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            margin: 0 4px 0 0;
        }
        
        .theme-btn:hover {
            transform: scale(1.15);
        }
        
        .theme-btn.active {
            border-color: white;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.3);
        }
        
        /* Square theme buttons */
        .theme-btn.square-btn {
            border-radius: 0;
            margin: 2px;
        }

        .theme-btn.square-btn.active {
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
        }
        
        .width-toggle {
            font-size: 10px;
            color: white;
        }
        
        /* Animation keyframes */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* --- CSS Animation for Marquee --- */
        @keyframes scrollText {
            /* 15s total duration: 2s initial delay handled by animation-delay */
            /* Loop: 8s scroll + 7s pause = 15s */
            0%   { transform: translateX(0); }     /* Start position */
            53.33% { transform: translateX(-50%); } /* Scroll halfway over 8s (8/15 = 53.33%) */
            100% { transform: translateX(-50%); } /* Hold end position for 7s (7/15 = 46.67%) */
        }
        
        .scroll-container {
            width: 100%;
            overflow: hidden;
        }
        
        .scroll-text {
            white-space: nowrap;
            display: inline-block; /* Important for width calculation */
            position: relative; /* Needed for JS transform animation */
            /* padding-right removed - spacing handled by JS */
            /* transition will be added by JS */
        }
        
        /* Apply animation via this class */
        .scroll-text.scrolling-active {
            /* Apply animation with initial delay */
            animation: scrollText 15s linear 2s infinite; /* 15s duration, 2s initial delay, infinite loop */
            /* Ensure transform is reset if class is removed */
            transform: translateX(0); 
        }
        
        .not-playing {
            font-style: italic;
            opacity: 0.7;
        }
        
        .error-container {
            border-radius: 8px;
            padding: 10px;
            margin: 10px;
            font-size: 14px;
            max-width: 500px;
            display: none;
            transition: all 0.3s ease;
        }
        
        .debug-title {
            font-weight: bold;
            margin-bottom: 6px;
        }
        
        /* THEMES */
        
        /* Natural (Default) Theme */
        .theme-natural {
            font-family: 'Comfortaa', cursive;
        }
        
        .theme-natural .music-container {
            background-color: rgba(245, 242, 235, 0.85);
            border-radius: 16px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 2px solid #6d9b78;
        }
        
        .theme-natural .note-icon {
            background-color: #6d9b78;
            color: white;
        }
        
        .theme-natural .song-title {
            color: #3a3a3a;
        }
        
        .theme-natural .song-artist {
            color: #5a5a5a;
        }
        
        .theme-natural .error-container {
            background-color: rgba(250, 235, 235, 0.85);
            border: 2px solid #c75c5c;
            color: #884444;
        }
        
        /* Twitch Theme */
        .theme-twitch {
            font-family: 'Inter', sans-serif;
        }
        
        .theme-twitch .music-container {
            background-color: rgba(35, 35, 45, 0.9);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(120, 88, 242, 0.5);
        }
        
        .theme-twitch .note-icon {
            background-color: rgb(100, 65, 164);
            color: white;
        }
        
        .theme-twitch .song-title {
            color: white;
        }
        
        .theme-twitch .song-artist {
            color: #b8b8b8;
        }
        
        .theme-twitch .error-container {
            background-color: rgba(50, 32, 45, 0.9);
            border: 1px solid #df4a76;
            color: #f5a5c3;
        }
        
        /* Dark Theme */
        .theme-dark {
            font-family: 'Rubik', sans-serif;
        }
        
        .theme-dark .music-container {
            background-color: rgba(18, 18, 18, 0.9);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
        }
        
        .theme-dark .note-icon {
            background-color: #333;
            color: #0cc0df;
        }
        
        .theme-dark .song-title {
            color: #ffffff;
        }
        
        .theme-dark .song-artist {
            color: #999;
        }
        
        .theme-dark .error-container {
            background-color: rgba(30, 20, 20, 0.9);
            border: 1px solid #662222;
            color: #dd7777;
        }
        
        /* Pink Theme */
        .theme-pink {
            font-family: 'Quicksand', sans-serif;
        }
        
        .theme-pink .music-container {
            background-color: rgba(255, 240, 250, 0.9);
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(219, 112, 219, 0.3);
            border: 2px solid #ffadd8;
        }
        
        .theme-pink .note-icon {
            background-color: #ff7ebc;
            color: white;
        }
        
        .theme-pink .song-title {
            color: #d13f96;
        }
        
        .theme-pink .song-artist {
            color: #9e7aa5;
        }
        
        .theme-pink .error-container {
            background-color: rgba(255, 235, 242, 0.9);
            border: 2px solid #ff8cb1;
            color: #c54275;
        }
        
        /* Light Theme */
        .theme-light {
            font-family: 'Poppins', sans-serif;
        }
        
        .theme-light .music-container {
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            border: 1px solid #e0e0e0;
        }
        
        .theme-light .note-icon {
            background-color: #4dabf7;
            color: white;
        }
        
        .theme-light .song-title {
            color: #2b2b2b;
        }
        
        .theme-light .song-artist {
            color: #757575;
        }
        
        .theme-light .error-container {
            background-color: rgba(255, 245, 245, 0.95);
            border: 1px solid #ffcdd2;
            color: #d32f2f;
        }
        
        /* Transparent Theme */
        .theme-transparent {
            font-family: 'Inter', sans-serif;
        }

        .theme-transparent .music-container {
            background-color: transparent;
            border-radius: 0;
            box-shadow: none;
            border: none;
        }

        .theme-transparent .note-icon,
        .theme-transparent .album-art {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 0;
        }

        .theme-transparent .song-title {
            color: white;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.7);
        }

        .theme-transparent .song-artist {
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.7);
        }
        
        .theme-transparent .error-container {
            background-color: rgba(0, 0, 0, 0.5);
            border: none;
            color: rgba(255, 255, 255, 0.9);
        }

        /* Neon Theme */
        .theme-neon {
            font-family: 'Quicksand', sans-serif;
        }

        .theme-neon .music-container {
            background-color: rgba(10, 10, 20, 0.85);
            border: 2px solid #0ff;
            border-radius: 0;
            box-shadow: 0 0 8px #0ff;
        }

        .theme-neon .note-icon,
        .theme-neon .album-art {
            background-color: #000;
            color: #0ff;
            border-radius: 0;
            border: 1px solid #0ff;
        }

        .theme-neon .song-title {
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
        }

        .theme-neon .song-artist {
            color: #ff00ff;
        }
        
        .theme-neon .error-container {
            background-color: rgba(10, 10, 20, 0.85);
            border: 2px solid #ff00ff;
            color: #ff00ff;
        }

        /* Terminal Theme */
        .theme-terminal {
            font-family: 'JetBrains Mono', monospace;
        }

        .theme-terminal .music-container {
            background-color: #000;
            border: 1px solid #00ff00;
            border-radius: 0;
            box-shadow: none;
        }

        .theme-terminal .note-icon,
        .theme-terminal .album-art {
            background-color: #000;
            color: #00ff00;
            border: 1px solid #00ff00;
            border-radius: 0;
        }

        .theme-terminal .song-title {
            color: #00ff00;
        }

        .theme-terminal .song-artist {
            color: #00bb00;
        }
        
        .theme-terminal .error-container {
            background-color: #000;
            border: 1px solid #00ff00;
            color: #00ff00;
        }

        /* Retro Theme */
        .theme-retro {
            font-family: 'Retro Gaming', monospace;
        }

        .theme-retro .music-container {
            background-color: #0000aa;
            border: 4px solid #ffff00;
            padding: 6px 16px;
            border-radius: 0;
        }

        .theme-retro .note-icon,
        .theme-retro .album-art {
            background-color: #000;
            color: #fff;
            border-radius: 0;
            border: 2px solid #ffff00;
        }

        .theme-retro .song-title {
            color: #ffffff;
        }

        .theme-retro .song-artist {
            color: #ffff00;
        }
        
        .theme-retro .error-container {
            background-color: #0000aa;
            border: 4px solid #ffff00;
            color: #ffff00;
        }

        /* High Contrast Theme */
        .theme-highcontrast {
            font-family: 'Atkinson Hyperlegible', sans-serif;
        }

        .theme-highcontrast .music-container {
            background-color: #000;
            border: 2px solid #fff;
            border-radius: 0;
            box-shadow: none;
        }

        .theme-highcontrast .note-icon,
        .theme-highcontrast .album-art {
            background-color: #000;
            color: #fff;
            border: 2px solid #fff;
            border-radius: 0;
        }

        .theme-highcontrast .song-title {
            color: #fff;
            font-weight: bold;
            font-size: 120%;
            font-family: 'Atkinson Hyperlegible', sans-serif;
        }

        .theme-highcontrast .song-artist {
            color: #fff;
            font-size: 110%;
        }
        
        .theme-highcontrast .error-container {
            background-color: #000;
            border: 2px solid #fff;
            color: #fff;
        }
    </style>
</head>
<body class="theme-natural">
    <div class="overlay-container width-fixed">
        <!-- Theme selector (appears on hover) -->
        <div class="theme-selector">
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <!-- Original rounded theme buttons -->
                <div style="display: flex; gap: 4px;">
                    <div class="theme-btn active" data-theme="natural" style="background-color: #6d9b78;" title="Natural"></div>
                    <div class="theme-btn" data-theme="twitch" style="background-color: rgb(100, 65, 164);" title="Twitch"></div>
                    <div class="theme-btn" data-theme="dark" style="background-color: #121212;" title="Dark"></div>
                    <div class="theme-btn" data-theme="pink" style="background-color: #ff7ebc;" title="Pink"></div>
                    <div class="theme-btn" data-theme="light" style="background-color: #ffffff;" title="Light"></div>
                </div>
                
                <!-- New square theme buttons -->
                <div style="display: flex; gap: 4px;">
                    <div class="theme-btn square-btn" data-theme="transparent" style="background-color: transparent; border: 1px dashed #ffffff;" title="Transparent"></div>
                    <div class="theme-btn square-btn" data-theme="neon" style="background-color: #000; border: 2px solid #0ff;" title="Neon"></div>
                    <div class="theme-btn square-btn" data-theme="terminal" style="background-color: #000; border: 1px solid #0f0;" title="Terminal"></div>
                    <div class="theme-btn square-btn" data-theme="retro" style="background-color: #00f; border: 2px solid #ff0;" title="Retro"></div>
                    <div class="theme-btn square-btn" data-theme="highcontrast" style="background-color: #000; border: 2px solid #fff;" title="High Contrast"></div>
                </div>
            </div>
            
            <!-- Width toggle button -->
            <div style="margin-left: 8px; border-left: 1px solid rgba(255,255,255,0.3); padding-left: 8px;">
                <div class="theme-btn width-toggle" data-width="adaptive" style="background-color: #444;" title="Adaptive Width">A</div>
                <div class="theme-btn width-toggle active" data-width="fixed" style="background-color: #444;" title="Fixed Width">F</div>
            </div>
        </div>
        
        <div class="music-container" id="musicContainer">
            <div id="artworkContainer" class="note-icon">♪</div>
            <div class="song-info">
                <div class="scroll-container">
                    <div class="scroll-text song-title" id="songTitle">
                        Loading...
                    </div>
                </div>
                <div class="scroll-container">
                    <div class="scroll-text song-artist" id="songArtist"></div>
                </div>
            </div>
        </div>
        
        <!-- Hidden debug info (only shown during troubleshooting) -->
        <div class="error-container" id="errorContainer">
            <div class="debug-title">Debug Information</div>
            <div id="errorText"></div>
        </div>
    </div>

    <script>
        // Debug mode - set to true to see errors
        const debugMode = false;
        
        // How often to check for updates (in milliseconds)
        const refreshInterval = 3000;
        
        // API endpoint
        const apiEndpoint = '/nowplaying';
        
        // Keep track of previous state
        let previousState = null;
        let containerVisible = true;
        let errorCount = 0;
        
        // Parse URL parameters
        function getUrlParams() {
            const params = {};
            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);
            
            // Get scene parameter
            const scene = urlParams.get('scene');
            if (scene) {
                params.scene = scene;
            }
            
            return params;
        }
        
        // Get URL parameters
        const urlParams = getUrlParams();
        const currentScene = urlParams.scene || 'default';
        
        // Get scene-specific setting from localStorage with fallback
        function getSceneStorage(key, defaultValue) {
            // Try to get scene-specific setting first
            const sceneSpecific = localStorage.getItem(`${currentScene}_${key}`);
            if (sceneSpecific !== null) {
                return sceneSpecific;
            }
            
            // Fall back to global setting if available
            const global = localStorage.getItem(key);
            if (global !== null) {
                return global;
            }
            
            // Use default value if nothing is stored
            return defaultValue;
        }
        
        // Save setting with scene-specific storage
        function setSceneStorage(key, value) {
            localStorage.setItem(`${currentScene}_${key}`, value);
        }
        
        // Theme selection
        const themeButtons = document.querySelectorAll('.theme-btn[data-theme]');
        const widthButtons = document.querySelectorAll('.width-toggle');
        const container = document.querySelector('.overlay-container');
        
        // Migration: Copy global settings to default scene if needed
        if (currentScene === 'default' && localStorage.getItem('musicPlayerTheme') !== null && 
            localStorage.getItem('default_musicPlayerTheme') === null) {
            
            // Migrate theme setting
            if (localStorage.getItem('musicPlayerTheme')) {
                let oldTheme = localStorage.getItem('musicPlayerTheme');
                // Migrate old polar theme name to natural
                if (oldTheme === 'polar') {
                    oldTheme = 'natural';
                }
                localStorage.setItem('default_musicPlayerTheme', oldTheme);
            }
            
            // Migrate width setting
            if (localStorage.getItem('musicPlayerWidth')) {
                localStorage.setItem('default_musicPlayerWidth', localStorage.getItem('musicPlayerWidth'));
            }
        }
        
        // Get saved theme or use default
        const savedTheme = getSceneStorage('musicPlayerTheme', 'natural');
        document.body.className = `theme-${savedTheme}`;
        
        // Get saved width setting or use default (now 'fixed')
        const savedWidth = getSceneStorage('musicPlayerWidth', 'fixed');
        if (savedWidth === 'fixed') {
            container.classList.remove('width-adaptive');
            container.classList.add('width-fixed');
        } else {
            container.classList.add('width-adaptive');
            container.classList.remove('width-fixed');
        }
        
        // Update active button states
        themeButtons.forEach(btn => {
            if (btn.dataset.theme === savedTheme) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
        
        widthButtons.forEach(btn => {
            if (btn.dataset.width === savedWidth) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
        
        // Add click handlers for theme buttons
        themeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const theme = btn.dataset.theme;
                
                // Update body class
                document.body.className = `theme-${theme}`;
                
                // Update active state
                themeButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Save selection with scene context
                setSceneStorage('musicPlayerTheme', theme);
                
                // Re-check if scrolling is needed after theme change (container size might change)
                requestAnimationFrame(() => { // Use rAF to ensure styles are applied first
                    songTitleMarquee._checkNeedsScroll(); // No parameter needed now
                    songArtistMarquee._checkNeedsScroll(); // No parameter needed now
                });
            });
        });
        
        // Add click handlers for width toggle
        widthButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const width = btn.dataset.width;
                
                // Update container class
                if (width === 'fixed') {
                    container.classList.remove('width-adaptive');
                    container.classList.add('width-fixed');
                } else {
                    container.classList.add('width-adaptive');
                    container.classList.remove('width-fixed');
                }
                
                // Update active state
                widthButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Save selection with scene context
                setSceneStorage('musicPlayerWidth', width);
                
                // Re-check if scrolling is needed after width change
                 requestAnimationFrame(() => { // Use rAF to ensure styles are applied first
                    songTitleMarquee._checkNeedsScroll(); // No parameter needed now
                    songArtistMarquee._checkNeedsScroll(); // No parameter needed now
                });
            });
        });

        // --- New Marquee Controller Logic ---
        class MarqueeController {
            constructor(textElementId) {
                this.textElement = document.getElementById(textElementId);
                this.container = this.textElement.parentElement;
                this.originalText = '';
                this.isScrolling = false;
                this.needsScroll = false;
                // Timers and duration properties removed - handled by CSS
                this.animationFrameRequest = null;
            }

            _measureWidths() {
                // Measure container width directly
                const containerWidth = this.container.clientWidth;
                
                // Use a clone with the original text for accurate text width measurement
                const clone = this.textElement.cloneNode(true);
                clone.style.display = "inline-block";
                clone.style.width = "auto";
                clone.style.position = "absolute";
                clone.style.visibility = "hidden";
                clone.textContent = this.originalText; // Ensure clone has original text
                document.body.appendChild(clone);
                const textWidth = clone.offsetWidth;
                document.body.removeChild(clone);

                // Return measured widths without modifying the live element here
                return { textWidth, containerWidth };
            }

            _checkNeedsScroll() { // Removed triggerInitialScroll parameter
                // Clear any pending animation frame requests for measurement
                cancelAnimationFrame(this.animationFrameRequest); 
                
                // Reset visual state before measurement (remove animation class)
                this.textElement.classList.remove('scrolling-active');
                this.textElement.style.transform = 'translateX(0)'; // Ensure reset
                // The line setting style.animation = 'none' was removed as it conflicts with the class-based animation.
                
                // Set text content to original for measurement consistency
                this.textElement.textContent = this.originalText; 

                // Use rAF to ensure DOM is updated before measuring
                this.animationFrameRequest = requestAnimationFrame(() => {
                    // Perform measurement using the clean original text state
                    const { textWidth, containerWidth } = this._measureWidths();
                    this.needsScroll = textWidth > containerWidth;

                    // Now, update text content and apply/remove class based on whether scroll is needed
                    if (this.needsScroll) {
                        console.log(`[${this.textElement.id}] Needs scroll. Applying CSS animation.`);
                        // Add duplicate text with spacing
                        this.textElement.textContent = this.originalText + '\u00A0\u00A0\u00A0\u00A0' + this.originalText;
                        // Add class to enable CSS animation
                        this.textElement.classList.add('scrolling-active');
                    } else {
                        console.log(`[${this.textElement.id}] No scroll needed.`);
                        // Ensure original text is displayed if no scroll needed
                        this.textElement.textContent = this.originalText;
                        // Ensure animation class is removed
                        this.textElement.classList.remove('scrolling-active');
                    }
                });
            }

            // _performScroll method removed - animation handled by CSS
            
            // _scheduleNextScroll method removed - animation handled by CSS

            updateText(newText) {
                const textChanged = newText !== this.originalText;
                
                // Stop any ongoing scroll/timers before updating
                this.stop(); // Ensures animation class is removed and text reset
                
                this.originalText = newText || ''; // Handle null/undefined
                this.textElement.textContent = this.originalText; // Set initial text
                
                if (this.originalText) {
                    // Check if scroll is needed and apply/remove class
                    this._checkNeedsScroll(); 
                } else {
                    // No text, ensure needsScroll is false and element is empty
                    this.needsScroll = false; 
                    this.textElement.textContent = '';
                    this.textElement.classList.remove('scrolling-active'); // Ensure class is removed
                }
            }

            stop() {
                 console.log(`[${this.textElement.id}] Stopping marquee (removing class).`);
                // Timers removed
                cancelAnimationFrame(this.animationFrameRequest); // Cancel pending measurement checks
                this.isScrolling = false; // Keep for potential future state checks, though not used for animation now
                
                // Reset visual state by removing class and styles
                this.textElement.classList.remove('scrolling-active');
                this.textElement.style.animation = 'none'; // Stop CSS animation immediately
                this.textElement.style.transform = 'translateX(0)'; // Reset position
                
                // Reset text content to the base original text
                this.textElement.textContent = this.originalText; 
            }
            
            clear() {
                 console.log(`[${this.textElement.id}] Clearing marquee.`);
                this.stop();
                this.originalText = '';
                this.textElement.textContent = '';
            }
        }

        // Instantiate controllers for title and artist
        const songTitleMarquee = new MarqueeController('songTitle');
        const songArtistMarquee = new MarqueeController('songArtist');
        // --- End Marquee Controller Logic ---
        
        // Function to show debug error
        function showDebugError(message, error) {
            if (debugMode) {
                const errorContainer = document.getElementById('errorContainer');
                const errorText = document.getElementById('errorText');
                
                errorContainer.style.display = 'block';
                errorText.textContent = `Error: ${message}\n${error ? error.toString() : ''}`;
                
                // Log to console as well
                console.error(message, error);
            }
        }

        // Old applyMarqueeIfNeeded function removed
        
        // Function to fetch and display song info
        function updateNowPlaying() {
            fetch(apiEndpoint + '?t=' + new Date().getTime(), {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status} ${response.statusText}`);
                }
                return response.text();
            })
            .then(text => {
                // Make sure we have some content
                if (!text || text.trim() === '') {
                    throw new Error('Empty response from server');
                }
                
                // Try to parse as JSON
                try {
                    const data = JSON.parse(text);
                    errorCount = 0; // Reset error count on success
                    
                    // Only update the UI if the data has changed
                    if (JSON.stringify(data) !== JSON.stringify(previousState)) {
                        const container = document.getElementById('musicContainer');
                        
                        if (data.playing) {
                            // Show container if hidden
                            if (!containerVisible) {
                                container.classList.remove('hidden');
                                containerVisible = true;
                            }
                            
                            // Animate if song changed
                            if (!previousState || previousState.title !== data.title) {
                                container.style.animation = 'none';
                                container.offsetHeight; // Trigger reflow
                                container.style.animation = 'fadeIn 0.5s ease-in-out';
                            }
                            
                            const songTitleEl = document.getElementById('songTitle');
                            const songArtistEl = document.getElementById('songArtist');
                            
                            const titleText = data.title;
                            const artistAlbumText = data.artist + (data.album ? ` • ${data.album}` : '');
                            
                            songTitleEl.classList.remove('not-playing');
                            
                            // Update text using Marquee Controllers ONLY if text changed
                            if (!previousState || titleText !== previousState.title) {
                                console.log(`[Main] Title changed: "${previousState?.title}" -> "${titleText}". Updating marquee.`);
                                songTitleMarquee.updateText(titleText);
                            } else {
                                // If text didn't change, but maybe container size did, 
                                // we could potentially re-check scroll needs without triggering initial delay.
                                // For now, let's keep it simple and only update on text change.
                                // songTitleMarquee._checkNeedsScroll(false); // Example: re-check without initial delay
                            }
                            
                            const prevArtistAlbumText = (previousState?.artist || '') + (previousState?.album ? ` • ${previousState.album}` : '');
                            if (!previousState || artistAlbumText !== prevArtistAlbumText) {
                                console.log(`[Main] Artist/Album changed: "${prevArtistAlbumText}" -> "${artistAlbumText}". Updating marquee.`);
                                songArtistMarquee.updateText(artistAlbumText);
                            } else {
                                // songArtistMarquee._checkNeedsScroll(false); // Example: re-check without initial delay
                            }
                            
                            // Update artwork
                            const artworkContainer = document.getElementById('artworkContainer');
                            
                            if (data.artworkPath) {
                                // Use the artworkPath provided by the JSON response
                                if (!previousState || previousState.artworkPath !== data.artworkPath) {
                                    // Preload the new image first
                                    const newImg = new Image();
                                    newImg.onload = function() {
                                        artworkContainer.innerHTML = `<img src="${data.artworkPath}" alt="Album art">`;
                                        artworkContainer.className = 'album-art';
                                    };
                                    newImg.src = data.artworkPath;
                                }
                            } else {
                                // No artwork, show music note
                                artworkContainer.innerHTML = '♪';
                                artworkContainer.className = 'note-icon';
                            }
                            
                            // Marquee logic is now handled by the controllers
                            
                        } else {
                            // Stop marquees and clear text if not playing or error
                            songTitleMarquee.clear(); // Clear text and stop animation
                            songArtistMarquee.clear(); // Clear text and stop animation

                            // Show error message if there's an error message
                            if (data.error) {
                                // Display error message in title area, stop its marquee
                                songTitleMarquee.updateText("Music information unavailable"); 
                                document.getElementById('songTitle').classList.add('not-playing');
                                // Artist marquee already cleared by .clear() above
                                
                                if (debugMode) {
                                    showDebugError(`Server reports issue: ${data.error}`);
                                }
                            } else {
                                // Hide container when not playing (marquees already stopped/cleared)
                                if (containerVisible) {
                                    container.classList.add('hidden');
                                    containerVisible = false;
                                }
                            }
                        }
                        
                        previousState = data;
                    }
                    
                    // Hide any error messages
                    if (!debugMode) {
                        document.getElementById('errorContainer').style.display = 'none';
                    }
                } catch (parseError) {
                    showDebugError('JSON parsing error', parseError);
                    throw parseError;
                }
            })
            .catch(error => {
                errorCount++;
                
                if (errorCount > 3) {
                    // Stop marquees and show connection error
                    songTitleMarquee.updateText("Connection error");
                    songArtistMarquee.clear(); // Clear artist line
                    document.getElementById('songTitle').classList.add('not-playing');
                    
                    showDebugError('Error fetching now playing info', error);
                }
            });
        }
        
        // If in debug mode, show the current scene in console
        if (debugMode) {
            console.log(`Current scene: ${currentScene}`);
            console.log(`Theme for this scene: ${savedTheme}`);
            console.log(`Width for this scene: ${savedWidth}`);
        }
        
        // Update immediately and then at regular intervals
        updateNowPlaying();
        setInterval(updateNowPlaying, refreshInterval);
    </script>
</body>
</html>
